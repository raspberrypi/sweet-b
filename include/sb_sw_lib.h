/** @file sb_sw_lib.h
 *  @brief public API for operations on short Weierstrass elliptic curves
 */

/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This file is part of Sweet B, a safe, compact, embeddable library for
 * elliptic curve cryptography.
 *
 * https://github.com/westerndigitalcorporation/sweet-b
 *
 * Copyright (c) 2020 Western Digital Corporation or its affiliates.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SB_SW_LIB_H
#define SB_SW_LIB_H

// sb_sw_lib.h: the main entry point for short-Weierstrass curves

#include <stdint.h>

#include <sb_types.h>
#include <sb_hmac_drbg.h>
#include <sb_sha256.h>
#include <sb_hkdf.h>
#include <sb_sw_context.h>
#include <sb_sw_curve_support.h>

#define SB_SW_ENDIANITY SB_DATA_ENDIAN_BIG

// see sb_types.h for the definition of sb_single_t and sb_double_t

/** A private key for a 256-bit short Weierstrass curve. */
typedef sb_single_t sb_sw_private_t;

/** A shared secret generated by ECDH on a 256-bit short Weierstrass curve. */
typedef sb_single_t sb_sw_shared_secret_t;

/** A message digest used as input to ECDSA signing on a 256-bit short
 * Weierstrass curve. */
typedef sb_single_t sb_sw_message_digest_t;

/** A public key on a 256-bit short Weierstrass curve. */
typedef sb_double_t sb_sw_public_t;

/** The X coordinate of a public key on a 256-bit short Weierstrass curve. */
typedef sb_single_t sb_sw_compressed_t;

/** An ECDSA signature on a 256-bit short Weierstrass curve. */
typedef sb_double_t sb_sw_signature_t;

/** @def SB_SW_FIPS186_4_CANDIDATES
 *  @brief The number of candidates to be tested for private key and
 *  per-message secret generation. This is set to a number that reduces the
 *  probability of failure to an acceptably low threshold. For both NIST P-256
 *  and secp256k1, the default value has a failure probability of <2^-256. */
#define SB_SW_FIPS186_4_CANDIDATES SB_SW_CONTEXT_PARAM_BUF_ELEMS

/** @brief Enumeration of short Weierstrass curves supported by Sweet B. Pass
 *  the appropriate curve identifier to Sweet B functions when performing
 *  curve operations. */
typedef enum sb_sw_curve_id_value_t {
#if SB_SW_P256_SUPPORT
    /** NIST P-256 */
        SB_SW_CURVE_P256 = 0,
#endif
#if SB_SW_SECP256K1_SUPPORT
    /** SECG secp256k1 */
        SB_SW_CURVE_SECP256K1 = 1,
#endif
#ifdef SB_TEST
    SB_SW_CURVE_INVALID = 0x7FFFFFFF
#endif
} sb_sw_curve_id_value_t;

/** Wrapper for ::sb_sw_curve_id_value_t values for ABI stability. */
typedef uint32_t sb_sw_curve_id_t;

// see sb_types.h for the definition of sb_data_endian_t

/** @name Short Weierstrass curve functions
 * All of the following methods take an initial parameter of type
 * ::sb_sw_context_t. You are responsible for allocating this context
 * structure. You may allocate different structures for each call or reuse
 * the same structure multiple times. The context is small (512 bytes) and
 * may be stack allocated.
 *
 * All of the following functions return ::sb_error_t. ::sb_error_t the
 * bitwise or of multiple error values; you MUST test for specific error
 * values by checking whether the appropriate bit is set in the return value.
 * Four errors (::SB_ERROR_CURVE_INVALID, ::SB_ERROR_RESEED_REQUIRED,
 * ::SB_ERROR_DRBG_FAILURE, and ::SB_ERROR_DRBG_UNINITIALIZED) are
 * returned immediately, which is to say that no further computation is
 * performed if any of these errors occurs. If the function accepts a
 * private or public key, the key(s) will be validated before any computation
 * is performed. Otherwise, these functions will run to completion in
 * constant time with respect to the non-curve inputs; if the function
 * produces output, the output returned will be junk if the return value is
 * not ::SB_SUCCESS. See ::sb_sw_valid_public_key and
 * ::sb_sw_verify_signature for notes on the return value of these functions.
 *
 * Most of these functions accept a DRBG as a parameter. For private key
 * generation, the DRBG is a mandatory parameter and must be properly seeded
 * from a hardware RNG. For public key validation, no DRBG is accepted as
 * there is no side channel mitigation for this operation. For signing, the
 * DRBG is an optional parameter and if supplied will be used for
 * FIPS-compatible randomized signatures and for side-channel mitigation. For
 * all other operations, the DRBG is an optional parameter and is used only for
 * side-channel mitigations. When a DRBG is supplied, any of these functions
 * may return ::SB_ERROR_RESEED_REQUIRED or ::SB_ERROR_DRBG_UNINITIALIZED. Any
 * function which accepts a DRBG, either optionally or as a mandatory
 * parameter, may also return ::SB_ERROR_DRBG_FAILURE. This error is expected
 * to occur only in extremely low probability cases.
 *
 * If you are unfamiliar with the [static 1] syntax, this declaration tells
 * the compiler that the passed pointer is non-\c NULL.
 *
 * @{
 */


/** Using the given HMAC-DRBG instance, generate a private key and return it
 *  in \p private. You are responsible for ensuring that the HMAC-DRBG
 *  instance supplied has been seeded with sufficient entropy at
 *  initialization time.
 *
 *  This is the only method which requires a HMAC-DRBG instance to be passed.
 *  You do not need to use this method to generate private keys. Alternatively,
 *  you could repeatedly call ::sb_sw_compute_public_key with random bytes
 *  until it succeeds.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] private Private key generated using \p drbg.
 *  @param [in,out] drbg HMAC-DRBG instance used to generate the private key.
 *  @param [in] curve Curve to generate the key on.
 *  @param [in] e Endianness of generated private key. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, if the DRBG must be reseeded, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */

extern sb_error_t sb_sw_generate_private_key(sb_sw_context_t context[static 1],
                                             sb_sw_private_t private[static 1],
                                             sb_hmac_drbg_state_t drbg[static 1],
                                             sb_sw_curve_id_t curve,
                                             sb_data_endian_t e);

/** Using the given HKDF instance, generate a private key and return it in
 *  \p private. You are responsible for ensuring that the HKDF instance has
 *  been initialized properly.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] private Private key generated using \p hkdf.
 *  @param [in,out] hkdf HKDF instance used to generate the private key.
 *  @param [in] info Optional context-specific information. May be NULL
 *  iff \p info_len is zero. Must not alias \p hkdf or \p private.
 *  @param [in] info_len Length of optional context-specific information,
 *  in bytes.
 *  @param [in] curve Curve to generate the key on.
 *  @param [in] e Endianness of generated private key. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, if the DRBG must be reseeded, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */

extern sb_error_t sb_sw_hkdf_expand_private_key
    (sb_sw_context_t context[static 1],
     sb_sw_private_t private[static 1],
     sb_hkdf_state_t hkdf[static 1],
     const sb_byte_t* restrict info,
     size_t info_len,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Invert the private key, producing a private key that inverts a point
 *  multiplication by the original private key. Useful for blinding
 *  operations in various protocols.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] output Inverted private key.
 *  @param [in] private Private key to invert.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve to use when inverting the private key.
 *  @param [in] e Endianness of \p output and \p private. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, the private key supplied is invalid, if the optionally supplied
 *  DRBG requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_invert_private_key
    (sb_sw_context_t context[static 1],
     sb_sw_private_t output[static 1],
     const sb_sw_private_t private[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Returns the public key for the supplied private key. The \p drbg parameter
 *  is optional and is used for side channel mitigation.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] public Public key corresponding to the supplied \p private key.
 *  @param [in] private Private key to compute the public key for.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve to use when generating the public key.
 *  @param [in] e Endianness of \p private and \p public. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, the private key supplied is invalid, if the optionally supplied
 *  DRBG requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_compute_public_key(sb_sw_context_t context[static 1],
                                           sb_sw_public_t public[static 1],
                                           const sb_sw_private_t private[static 1],
                                           sb_hmac_drbg_state_t* drbg,
                                           sb_sw_curve_id_t curve,
                                           sb_data_endian_t e);

/** Begins computing the public key for the supplied private key. The \p drbg
 *  parameter is optional and is used for side channel mitigation.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] private Private key to compute the public key for.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve to use when generating the public key.
 *  @param [in] e Endianness of \p private. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, the private key supplied is invalid, if the optionally supplied
 *  DRBG requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_compute_public_key_start
    (sb_sw_context_t context[static 1],
     const sb_sw_private_t private[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Continues computing the public key for the supplied private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] done Indication of whether computation is done (no further
 *  progress can be made until the finish function is called).
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_compute_public_key_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_compute_public_key_continue
    (sb_sw_context_t context[static 1],
     _Bool done[static 1]);

/** Returns the public key for the supplied private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] public Public key corresponding to the supplied private key.
 *  @param [in] e Endianness of \p public. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_compute_public_key_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_compute_public_key_finish
    (sb_sw_context_t context[static 1],
     sb_sw_public_t public[static 1],
     sb_data_endian_t e);

/** Validate the supplied private key. You do not need to call this function
 *  explicitly in most cases, as functions which accept a private key will
 *  also validate the private key. However, in some situations, it may be
 *  useful to explicitly check whether a given key is valid.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] private Supplied private key to be validated.
 *  @param [in] curve Curve on which the supplied private key is supposedly a
 *  valid scalar.
 *  @param [in] e Endianness of the private key. Use big endian for
 *  most situations.
 *  @return Returns ::SB_SUCCESS if the supplied private key is valid or
 *  ::SB_ERROR_PRIVATE_KEY_INVALID exclusively if the key supplied is invalid.
 *  Fails if the curve supplied is invalid.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_valid_private_key(sb_sw_context_t context[static 1],
                                          const sb_sw_private_t private[static 1],
                                          sb_sw_curve_id_t curve,
                                          sb_data_endian_t e);

/** Validate the supplied public key. You do not need to call this function
 *  explicitly in most cases, as functions which accept a public key will
 *  also validate the public key. However, in some protocols, it may be
 *  useful to validate a key upon receipt.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] public Supplied public key to be validated.
 *  @param [in] curve Curve on which the supplied public key supposedly lies.
 *  @param [in] e Endianness of the public key. Use big endian for
 *  most situations.
 *  @return Returns ::SB_SUCCESS if the supplied public key is valid or
 *  ::SB_ERROR_PUBLIC_KEY_INVALID if the key supplied is invalid.
 *  Fails if the curve supplied is invalid.
 *  @memberof sb_sw_context_t
 */

extern sb_error_t sb_sw_valid_public_key(sb_sw_context_t context[static 1],
                                         const sb_sw_public_t public[static 1],
                                         sb_sw_curve_id_t curve,
                                         sb_data_endian_t e);

/** Compress the supplied public key into a single ::SB_ELEM_BYTES long
 *  value and an extra "sign" bit. If the key is only to be used for shared
 *  secret generation, the "sign" bit may be ignored.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] compressed Compressed representation of the public key.
 *  @param [out] sign Sign bit for the public key.
 *  @param [in] public Public key to be compressed.
 *  @param [in] curve Curve on which the supplied public key lies.
 *  @param [in] e Endianness of the public key. Use big endian for
 *  most situations.
 *
 *  @return Returns ::SB_SUCCESS if the supplied public key is valid or
 *  ::SB_ERROR_PUBLIC_KEY_INVALID if the key supplied is invalid.
 *  Fails if the curve supplied is invalid.
 *  @memberof sb_sw_context_t
 */

extern sb_error_t sb_sw_compress_public_key(sb_sw_context_t context[static 1],
                                            sb_sw_compressed_t compressed[static 1],
                                            _Bool sign[static 1],
                                            const sb_sw_public_t public[static 1],
                                            sb_sw_curve_id_t curve,
                                            sb_data_endian_t e);

/** Decompress the supplied compressed public key using an extra "sign" bit.
 *  If the key is to be used only for shared secret generation, the "sign"
 *  bit may be either 0 or 1, with no effect on the result.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] public Decompressed public key output.
 *  @param [in] compressed Compressed representation of the public key.
 *  @param [in] sign Sign bit for the public key.
 *  @param [in] curve Curve on which the supplied public key supposedly lies.
 *  @param [in] e Endianness of the public key. Use big endian for
 *  most situations.
 *
 *  @return Returns ::SB_SUCCESS if the supplied public key is valid or
 *  ::SB_ERROR_PUBLIC_KEY_INVALID if the key supplied is invalid.
 *  Fails if the curve supplied is invalid.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_decompress_public_key(sb_sw_context_t context[static 1],
                                              sb_sw_public_t public[static 1],
                                              const sb_sw_compressed_t compressed[static 1],
                                              _Bool sign,
                                              sb_sw_curve_id_t curve,
                                              sb_data_endian_t e);

/** Generate an ECDH shared secret using the given private key and public key.
 *  You SHOULD use this shared secret as input to a key-derivation function
 *  (KDF) instead of using it directly. Selection of an appropriate KDF is
 *  application-specific and outside the scope of Sweet B; however, most
 *  hash-based KDFs are easily implemented using the supplied SHA256 and
 *  HMAC-SHA256 procedures. See RFC5869 for one such KDF scheme, and NIST
 *  SP800-56A rev. 2 for details on a single-step SHA256-based scheme.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] secret Generated shared secret.
 *  @param [in] private Supplied private key.
 *  @param [in] public Supplied public key. Will be validated before use.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the ECDH shared secret.
 *  @param [in] e Endianness of the \p private and \p public keys. Use big
 *  endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve,
 *  private, or public keys are invalid, if the optionally supplied DRBG
 *  requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_shared_secret(sb_sw_context_t context[static 1],
                                      sb_sw_shared_secret_t secret[static 1],
                                      const sb_sw_private_t private[static 1],
                                      const sb_sw_public_t public[static 1],
                                      sb_hmac_drbg_state_t* drbg,
                                      sb_sw_curve_id_t curve,
                                      sb_data_endian_t e);

/** Begins generating an ECDH shared secret using the given private key and
 *  public key. See ::sb_sw_shared_secret for notes on how to use the
 *  output of this function.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] private Supplied private key.
 *  @param [in] public Supplied public key. Will be validated before use.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the ECDH shared secret.
 *  @param [in] e Endianness of the \p private key. Use big endian for most
 *  situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve,
 *  private, or public keys are invalid, if the optionally supplied DRBG
 *  requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_shared_secret_start
    (sb_sw_context_t context[static 1],
     const sb_sw_private_t private[static 1],
     const sb_sw_public_t public[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Continues generating an ECDH shared secret using the given private key and
 *  public key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] done Indication of whether computation is done (no further
 *  progress can be made until the finish function is called).
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_shared_secret_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_shared_secret_continue
    (sb_sw_context_t context[static 1],
     _Bool done[static 1]);

/** Finishes generating an ECDH shared secret using the given private key and
 *  public key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] secret Generated shared secret.
 *  @param [in] e Endianness of the \p secret. Use big endian for most
 *  situations.
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_shared_secret_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_shared_secret_finish
    (sb_sw_context_t context[static 1],
     sb_sw_shared_secret_t secret[static 1],
     sb_data_endian_t e);

/** Multiply the given public key by the given private key. This is
 *  equvialent to ::sb_sw_shared_secret, except it returns the full X and
 *  Y coordinates of the output point, instead of just the X coordinate. It
 *  is more efficient to use this method than a combination of
 *  ::sb_sw_shared_secret and ::sb_sw_decompress_public_key in protocols
 *  that need a full X and Y coordinate output, and it avoids the loss of the
 *  "sign" bit.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] output Result of the point multiplication.
 *  @param [in] private Supplied private key.
 *  @param [in] public Supplied public key. Will be validated before use.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the ECDH shared secret.
 *  @param [in] e Endianness of the \p public key and \p output point. Use big
 *  endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve,
 *  private, or public keys are invalid, if the optionally supplied DRBG
 *  requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_point_multiply(sb_sw_context_t context[static 1],
                                       sb_sw_public_t output[static 1],
                                       const sb_sw_private_t private[static 1],
                                       const sb_sw_public_t public[static 1],
                                       sb_hmac_drbg_state_t* drbg,
                                       sb_sw_curve_id_t curve,
                                       sb_data_endian_t e);

/** Begins multiplying the given public key by the given private key. See
 *  ::sb_sw_point_multiply for notes on how to use this function.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] private Supplied private key.
 *  @param [in] public Supplied public key. Will be validated before use.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the ECDH shared secret.
 *  @param [in] e Endianness of the \p public key. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve,
 *  private, or public keys are invalid, if the optionally supplied DRBG
 *  requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_point_multiply_start
    (sb_sw_context_t context[static 1],
     const sb_sw_private_t private[static 1],
     const sb_sw_public_t public[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Continues multiplying the given public key by the given private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] done Indication of whether computation is done (no further
 *  progress can be made until the finish function is called).
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_point_multiply_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_point_multiply_continue
    (sb_sw_context_t context[static 1],
     _Bool done[static 1]);

/** Finishes multiplying the given public key by the given private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] output Result of the point multiplication.
 *  @param [in] e Endianness of the \p output point. Use big endian for
 *  most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_point_multiply_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_point_multiply_finish
    (sb_sw_context_t context[static 1],
     sb_sw_public_t output[static 1],
     sb_data_endian_t e);

/** Signs the SHA256 digest of the supplied message using the provided private
 *  key. If a \p drbg is supplied, it will be used for the per-message secret
 *  generation as per FIPS 186-4. The private key and message are used as
 *  additional input to the \p drbg to ensure that the per-message secret is
 *  always unique per (private key, message) combination. If no \p drbg is
 *  supplied, RFC6979 deterministic secret generation is used instead.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] digest Computed digest of the supplied \p input.
 *  @param [out] signature Generated signature of the \p digest of the supplied
 *  \p input.
 *  @param [in] private Supplied private key to use for the signature operation.
 *  @param [in] input Input message to be signed.
 *  @param [in] input_len Length of \p input bytes.
 *  @param [in,out] drbg Optional DRBG to use for randomized signing. Will
 *  also be used to generate entropy for side-channel mitigations if supplied.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the private key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve or
 *  private key are invalid, if the optionally supplied DRBG requires
 *  reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_sha256
    (sb_sw_context_t context[static 1],
     sb_sw_message_digest_t digest[static 1],
     sb_sw_signature_t signature[static 1],
     const sb_sw_private_t private[static 1],
     const sb_byte_t* input,
     size_t input_len,
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Signs the 32-byte message digest using the provided private key. If a \p
 *  drbg is supplied, it will be used for the per-message secret generation
 *  as per FIPS 186-4. The private key and message are used as additional
 *  input to the \p drbg to ensure that the per-message secret is always
 *  unique per (private key, message) combination. If no \p drbg is
 *  supplied, RFC6979 deterministic secret generation is used instead.
 *
 *  It is recommended to use ::sb_sw_sign_message_sha256 or
 *  ::sb_sw_sign_message_sha256_start whenever possible. This routine is
 *  provided for use cases where a 256-bit message digest is already available,
 *  and has presumably been computed using ::sb_sha256_finish. If using this
 *  with message digests from other sources, you are responsible for ensuring
 *  that you are using a secure hash function. Do NOT call this routine with
 *  hashes of a different size (e.g. SHA-224 or SHA-512).
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] signature Generated signature of the supplied \p message
 *  digest.
 *  @param [in] private Supplied private key to use for the signature operation.
 *  @param [in] message Message digest to sign with the supplied \p private key.
 *  @param [in,out] drbg Optional DRBG to use for randomized signing. Will
 *  also be used to generate entropy for side-channel mitigations if supplied.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the private key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve or
 *  private key are invalid, if the optionally supplied DRBG requires
 *  reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_digest(sb_sw_context_t context[static 1],
                                            sb_sw_signature_t signature[static 1],
                                            const sb_sw_private_t private[static 1],
                                            const sb_sw_message_digest_t
                                            message[static 1],
                                            sb_hmac_drbg_state_t* drbg,
                                            sb_sw_curve_id_t curve,
                                            sb_data_endian_t e);

/** Begins signing the 32-byte message digest using the provided private key.
 *  See ::sb_sw_sign_message_digest for notes on how to use this function.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] private Supplied private key to use for the signature operation.
 *  @param [in] message Message digest to sign with the supplied \p private key.
 *  @param [in,out] drbg Optional DRBG to use for randomized signing. Will
 *  also be used to generate entropy for side-channel mitigations if supplied.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the private key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve or
 *  private key are invalid, if the optionally supplied DRBG requires
 *  reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_digest_start
    (sb_sw_context_t context[static 1],
     const sb_sw_private_t private[static 1],
     const sb_sw_message_digest_t
     message[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Finishes computing the SHA256 hash of previously provided input, and begins
 *  signing the resulting 32-byte message digest using the provided private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in,out] sha SHA256 state to use to obtain the message digest.
 *  @param [in] private Supplied private key to use for the signature operation.
 *  @param [in,out] drbg Optional DRBG to use for randomized signing. Will
 *  also be used to generate entropy for side-channel mitigations if supplied.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the private key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the supplied curve or
 *  private key are invalid, if the optionally supplied DRBG requires
 *  reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_sha256_start
    (sb_sw_context_t context[static 1],
     sb_sha256_state_t sha[static 1],
     const sb_sw_private_t private[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Continues signing the 32-byte message digest using the provided private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] done Indication of whether computation is done (no further
 *  progress can be made until the finish function is called).
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_sign_message_digest_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_digest_continue
    (sb_sw_context_t context[static 1],
     _Bool done[static 1]);

/** Finishes signing the 32-byte message digest using the provided private key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] signature Generated signature of the supplied \p message
 *  digest.
 *  @param [in] e Endianness of the \p signature. Use big endian for most
 *  situations.
 *  @return On success, ::SB_SUCCESS. Fails if the context has not been
 *  initialized by a prior to call to ::sb_sw_sign_message_digest_start.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_sign_message_digest_finish
    (sb_sw_context_t context[static 1],
     sb_sw_signature_t signature[static 1],
     sb_data_endian_t e);

/** Produces a modified message digest that, when signed by some external
 *  private key with public key P, creates a signature that can be processed
 *  by ::sb_sw_composite_sign_unwrap_signature to produce a valid
 *  signature under the composite public key \p private * P. The composite
 *  public key can be computed using ::sb_sw_point_multiply.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] wrapped Wrapped message digest.
 *  @param [in] message Original message digest to be wrapped.
 *  @param [in] private Private key to be combined with \p
 *  message_digest.
 *  @param [in] drbg Optional DRBG, used to generate entropy for side-channel
 *  mitigations.
 *  @param [in] curve The curve to use when wrapping the message.
 *  @param [in] e Endianness of \p output, \p private, and \p message_digest.
 *  Use big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid, the private key supplied is invalid, if the optionally supplied
 *  DRBG requires reseeding, or in case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_composite_sign_wrap_message_digest
    (sb_sw_context_t context[static 1],
     sb_sw_message_digest_t wrapped[static 1],
     const sb_sw_message_digest_t message[static 1],
     const sb_sw_private_t private[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Produces a modified signature of a message digest previously wrapped by
 *  ::sb_sw_composite_sign_wrap_message_digest and signed by some external
 *  private key with public key P. The result is a valid signature of the
 *  pre-wrapped message which can be verified using the composite public key
 *  private * P. The composite public key can be computed using
 *  ::sb_sw_point_multiply.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] unwrapped Unwrapped signature which can be verified using
 *  the composite public key.
 *  @param [in] signature ECDSA signature signed using a different private
 *  scalar.
 *  @param [in] private Private key to be combined with \p signature.
 *  @param [in] curve The curve to use when unwrapping the signature.
 *  @param [in] e Endianness of \p output, \p private, and \p signature. Use
 *  big endian for most situations.
 *  @return On success, ::SB_SUCCESS. Fails if the curve specified is
 *  invalid or if the private key supplied is invalid.
 *  @memberof sb_sw_context_t
 */
extern sb_error_t sb_sw_composite_sign_unwrap_signature
    (sb_sw_context_t context[static 1],
     sb_sw_signature_t unwrapped[static 1],
     const sb_sw_signature_t signature[static 1],
     const sb_sw_private_t private[static 1],
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Verifies a supplied signature of the SHA256 digest of a provided message
 *  using a given public key.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [out] digest Computed digest of the supplied \p input.
 *  @param [in] signature Signature to verify using the given \p public key
 *  and \p message digest.
 *  @param [in] public Public key to use for signature verification. Will be
 *  checked for validity before use.
 *  @param [in] input Input message to be verified.
 *  @param [in] input_len Length of \p input bytes.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the public key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return Returns ::SB_SUCCESS if the signature is valid or
 *  ::SB_ERROR_SIGNATURE_INVALID exclusively if the signature is invalid. Fails
 *  if the supplied curve or public key is invalid, if the optionally
 *  supplied drbg requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_verify_result_t sb_sw_verify_signature_sha256
    (sb_sw_context_t context[static 1],
     sb_sw_message_digest_t digest[static 1],
     const sb_sw_signature_t signature[static 1],
     const sb_sw_public_t public[static 1],
     const sb_byte_t* input,
     size_t input_len,
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

/** Verifies a supplied signature of a given message digest with a given
 *  public key.
 *
 *  It is recommended to use ::sb_sw_verify_signature_sha256 or
 *  ::sb_sw_verify_signature_sha256_start whenever possible. This routine is
 *  provided for use cases where a 256-bit message digest is already available,
 *  and has presumably been computed using ::sb_sha256_finish. If using this
 *  with message digests from other sources, you are responsible for ensuring
 *  that you are using a secure hash function. Do NOT call this routine with
 *  hashes of a different size (e.g. SHA-224 or SHA-512).
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in] signature Signature to verify using the given \p public key
 *  and \p message digest.
 *  @param [in] public Public key to use for signature verification. Will be
 *  checked for validity before use.
 *  @param [in] message Message digest to verify the signature of.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the signature.
 *  @return Returns ::SB_SUCCESS if the signature is valid or
 *  ::SB_ERROR_SIGNATURE_INVALID exclusively if the signature is invalid. Fails
 *  if the supplied curve or public key is invalid, if the optionally
 *  supplied drbg requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_verify_result_t sb_sw_verify_signature(sb_sw_context_t context[static 1],
                                                 const sb_sw_signature_t signature[static 1],
                                                 const sb_sw_public_t public[static 1],
                                                 const sb_sw_message_digest_t message[static 1],
                                                 sb_hmac_drbg_state_t* drbg,
                                                 sb_sw_curve_id_t curve);

// /** Begins verifying a supplied signature of a given message digest with a
//  *  given public key. See ::sb_sw_verify_signature for notes on how to use this
//  *  method.
//  *
//  *  @param [in] context Private context structure allocated by the caller.
//  *  @param [in] signature Signature to verify using the given \p public key
//  *  and \p message digest.
//  *  @param [in] public Public key to use for signature verification. Will be
//  *  checked for validity before use.
//  *  @param [in] message Message digest to verify the signature of.
//  *  @param [in,out] drbg Optional DRBG, used to generate entropy for
//  *  side-channel mitigations.
//  *  @param [in] curve Curve on which to generate the signature.
//  *  @return Returns ::SB_SUCCESS if verification has been started. Fails
//  *  if the supplied curve or public key is invalid, if the optionally
//  *  supplied drbg requires reseeding, or in the case of DRBG failure.
//  *  @memberof sb_sw_context_t
//  */
// extern sb_error_t sb_sw_verify_signature_start
//     (sb_sw_context_t context[static 1],
//      const sb_sw_signature_t signature[static 1],
//      const sb_sw_public_t public[static 1],
//      const sb_sw_message_digest_t message[static 1],
//      sb_hmac_drbg_state_t* drbg,
//      sb_sw_curve_id_t curve);

/** Finishes computing the SHA256 hash of a message, and begins verifying the
 *  supplied signature of the resulting digest with a given public key.
 *  See ::sb_sw_verify_signature for notes on how to use this method.
 *
 *  @param [in] context Private context structure allocated by the caller.
 *  @param [in,out] sha SHA256 state to use to obtain the message digest.
 *  @param [in] signature Signature to verify using the given \p public key
 *  and \p message digest.
 *  @param [in] public Public key to use for signature verification. Will be
 *  checked for validity before use.
 *  @param [in,out] drbg Optional DRBG, used to generate entropy for
 *  side-channel mitigations.
 *  @param [in] curve Curve on which to generate the signature.
 *  @param [in] e Endianness of the public key, message digest, and
 *  signature. Use big endian for most situations.
 *  @return Returns ::SB_SUCCESS if verification has been started. Fails
 *  if the supplied curve or public key is invalid, if the optionally
 *  supplied drbg requires reseeding, or in the case of DRBG failure.
 *  @memberof sb_sw_context_t
 */
extern sb_verify_result_t sb_sw_verify_signature_sha256_start
    (sb_sw_context_t context[static 1],
     sb_sha256_state_t sha[static 1],
     const sb_sw_signature_t signature[static 1],
     const sb_sw_public_t public[static 1],
     sb_hmac_drbg_state_t* drbg,
     sb_sw_curve_id_t curve,
     sb_data_endian_t e);

// /** Continues verifying a supplied signature of a given message digest with a
//  *  given public key.
//  *
//  *  @param [in] context Private context structure allocated by the caller.
//  *  @param [out] done Indication of whether computation is done (no further
//  *  progress can be made until the finish function is called).
//  *  @return On success, ::SB_SUCCESS. Fails if the context has not been
//  *  initialized by a prior to call to ::sb_sw_verify_signature_start.
//  *  @memberof sb_sw_context_t
//  */
// extern sb_error_t sb_sw_verify_signature_continue
//     (sb_sw_context_t context[static 1]);
//
// /** Finishes verifying a supplied signature of a given message digest with a
//  *  given public key.
//  *
//  *  @param [in] context Private context structure allocated by the caller.
//  *  @return Returns ::SB_SUCCESS if the signature is valid or
//  *  ::SB_ERROR_SIGNATURE_INVALID exclusively if the signature is invalid. Fails
//  *  if the context has not been initialized by a prior to call to
//  *  ::sb_sw_verify_signature_start.
//  *  @memberof sb_sw_context_t
//  */
// extern sb_error_t sb_sw_verify_signature_finish
//     (sb_sw_context_t context[static 1]);

/** @} */

#endif
